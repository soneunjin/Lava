# day07

배열의 정렬

	치환정렬을 해서 정렬을 한다.
	이 때 방법은
	처음부터 하나씩 꺼내고
	비교를 하는데 대상은 꺼낸 다음 데이터부터 끝까지 꺼내서 비교를 해서
	오름차순이라면
		대상이 더 작다면 현재 데이터와 교체를 해줘야 한다.
	이때 주의사항은
	현재데이터에 데이터를 입력하는 순간
	기존데이터는 사라질 것이고 찾을 방법이 없다.
	따라서 사라지기 전에 어딘가에 저장을 해둬야 한다.
	
----------------------------------------------------------------------------------------------------
# flag 기법

	==> 프로그램을 실행하다보면
		두가지 이상의 경우가 발생되는 순간이 존재한다.
		그 후에 어떤 경우가 발생이 되서 처리된 것인지 알아보는 기법
		
		예]
			
			for(){
				break; // 이 명령이 실행이 되면 (1)이 실행이 된다.
				(0)
			}
			(1)	
			==> 부분은 for명령이 정상적으로 종료된 후에 실행되는 부분이다.
			
			문제 ]
				(1) 부분은 실행할 때 정상적으로 종료되었는지?
				break; 명령을 만나서 종료되었는지??
				알 수 없다.
				
			방법 ]
				시작하기 전에 변수에 특정 데이터로 초기화를 시켜놓고
				특정 순간이 발생하면 변수의 데이터를 변경시킨다.
				(break 되기 바로 전에..)
				
				(1) 번 부분에서는 변수의 값에 따라서
				반복문이 정상적으로 모두 실행이 되었는지
				아니면 중간에 중단이 되었는지 판단 할 수 있게된다.
				
-----------------------------------------------------------------------

배열의 복사
	
	1. 얕은 복사
		==> 주소만 복사해주는 기법
		
			특징 ]
				데이터는 공유하므로 한 곳에서 수정하면
				다른곳에서도 수정된 데이터를 사용하게 된다.
				
			복사 방법 ]
				
				int[] num1 = new int[5];
				....
				
				int[] num2; ->  이것은 배열 주소를 기억할 변수를 만들어 주는 것.
								num2안에는 데이터는 기억할 수 없고
								오직 주소만 기억할 수 있다.
								
				
				num2 = num1;	==> 얕은 복사
				
			참고 ]
				얕은 복사는
				지역변수는 그 지역에서만(해당 블럭에서만) 활동하므로
				다른 지역에서 Heap 영역의 데이터를 사용할 목적으로 많이 사용되는 기법
				
				다른 지역에서 만든 Heap 영역의 데이터를
				다른 지역에서도 같이 사용할 목적으로 많이 사용되는 기법이다.
				
	2. 깊은 복사
		==> 데이터까지 모두 복사해주는 기법
			==> 데이터가 복사되는 것은
				Heap 영역에 다른곳에 데이터가 한번더 존재한다는 의미이므로
				데이터의 주소가 달라지게 되므로
				
			특징 ]
				복사된 데이터는 독립적으로 사용 된다.
				
			명령 ]
				System.arraycopy(#1, #2, #3, #4, #5);
				
					#1 - 원본 데이터의 주소
					#2 - 원본 데이터의 복사를 시작할 위치
					#3 - 복사받을 배열의 주소
					#4 - 복사 받을 배열의 입력 시작위치
					#5 - 복사 받을 데이터의 갯수
						 
--------------------------------------------------------------------------------

배열의 단점
	1. 한번 배열의 크기를 정하면 크기 조절이 불가능하다.
		예]
			int[] num = new int[10];
			// 정수 데이터를 10개 관리할 예정이다.
			// 이때 정수 데이터가 11개를 관리를 해야된다면???
			// 원칙적으로 불가능하다.
			// 해결 방법은 깊은 복사를 해준다.
			
			int[] num2 = new int[20];
			// num2의 앞부분에 깊은 복사로 데이터를 채워 넣으면
			// 이후 10개를 더 저장해서 사용할 수 있게 된다.
			
	2. 같은 타입의 데이터만 입력할 수 있다.
	
		==> 주소는 Heap Type에 의해서 결정되고
			Heap Type이 다르면 사용할 수 없다.( 호환이 안된다. )
			
		예]
			int[] no = new int[10];
			
			float[] no2;
			
			no2 = no;
=====================================================================

String 배열

	참고 ]
		String 역시 참조형 변수이다. 주소를 기억하고 있다.
		
		String str = "hong";
		이라고 정의를 하면
		
		str 속에는 Heap에 만들어진 주소를 기억을 하고 있다.
		"hong" 리터럴 풀에 기억이 된다.
		
	참고]
		문자열 만드는 방법 1]
			String 변수이름 = "데이터";
			
		문자열 만드는 방법 2]
			
			String 변수이름 = new String(문자열데이터);


	***
	문자열은 변경이 자주 일어나는 문자열의 경우
	String 타입으로 만들지 않고
	StringBuffer 나 StringBuild 타입으로 만들고 연산해서
	최종적으로 변경된 데이터를 String 타입으로 사용하는 것이 좋다.
	
		참고]
			레퍼런스 변수 란?
			주소를 기억하는 변수
			하지만 프로그램에서는 주소는 필요하지 않다.
			오직 데이터가 필요할 뿐이다.
			따라서 주소 변수는 데이터가 존재하는 위치를 알려줄 뿐이고
			핵심은 데이터가 들어갈 메모리, 실제 데이터가 더 중요하다.
	
	문자열 배열 만들기
	
		String[] 변수이름;
		변수이름 = new String[길이];
		==> String[] 변수이름 = new String[길이];
		
		변수이름[index] = 문자열데이터;
		
		문자열 배열도 초기화가 가능하다.
		String[] 변수이름 = {문자열1, 문자열2, ...};
		String[] 변수이름 = new String[] {문자열1, 문자열2, ...};
		
	String은 필요에 따라서 문자배열로 변환해서 사용할 수 있다.
		
		1.toCharArray()
			: 문자열을 문자배열로 반환해주는 함수		
			
		2. charAt(위치)
			: 해당 위치의 문자를 반환해주는 함수
			
		3. indexOf(문자)
			: 문자열에서 해당문자가 위치하는 위치값을 반환
			
		4. length()
			: 문자열의 길이를 반환해주는 함수
			
		5. substring()
			: 문자열중에서 원하는 문자열만 뽑아서 반환해주는 함수
			
			형식 1]
				substring(시작위치)
				==> 시작위치에서 부터 맨 마지막까지 추출해서 반환해주는 함수
				
			형식 2]
				substring(시작위치, 종료위치)
				==> 시작위치부터 종료위치까지 꺼내서 반환해주는 함수
				
				*
				주의 ]
					시작위치는 0부터 카운트를 하고
					종료위치는 반환 문자열에서 제외되서 반환된다.
					종료위치 전 문자까지만 추출해서 반환해준다.
					
		6. equals(문자열)
			==> 문자열의 데이터가 같은 값인지 비교하는 함수
			
			형식]
				문자열1.equals(문자열2)
				==> 반환값은 boolean타입의 데이터로 반환해준다.





	
--------------------------------------------------------------------
문제]
	45 ~ 1 까지 저장할 배열을 만들고
	배열에서 로또 번호를 꺼내서 로또 한게임을 만들고 출력하세요.
	
문제 1]
	
	알파벳 10개를 저장할 배열을 만들고
	대문자 10개를 랜덤하게 추출해서 배열에 저장하고
	저장된 배열을 얕은 복사로 복사해서
	출력하고,
	원래 배열을 소문자로 변경한 후
	두 배열을 출력하세요.
	
문제 2]
	
	정수 10개를 저장할 배열을 만들고
	랜덤하게 1 ~ 50까지 수 중 발생시켜서
	배열에 담고
	배열의 5번째까지의 데이터를 깊은 복사로 복사하세요.
	
문제 3]
	
	회원의 이름, 전화번호, 이메일을 저장할 배열을 만들고 - 문자열 배열 3개
	데이터를 입력해 놓고
	
	이름을 입력하면
	그 사람의 데이터를 모두 저장할 배열을 만들어서
	데이터를 넣고 출력하세요.
	
문제 4]
	전화번호를 입력하면
	'-'를 기준으로 데이터를 분리해서
	저장할 배열을 만들고 분리된 데이터를 순서에 맞게 입력하고 출력하세요.
	indexOf(),substring()

extra ]
	영문 문자열을 입력받아서
	해당 알파벳이 출현하는 빈도를 저장하고
	빈도를  * 로 표시하세요.
	
	
	
	
	
	