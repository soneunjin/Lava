# day15
	
	Object 클래스
		
		2. toString()
			==> 자바는 주소를 내부적으로 사용하고 있다.
				하지만 주소를 사용자(개발자)에게 노출하지는 않는다.
				
				대신 주소를 출력하면
					"클래스이름@해쉬코드값"
				의 형태로 출력을 한다.
				
				참고 ]
					해쉬코드
					==> 자바는 주소를 내부적으로 해쉬테이블을 이용해서 관리한다.
						해쉬코드값은 그 주소를 관리하는 해쉬테이블의 코드값이 된다.
						
				문제 ]
					주소를 출력하려고 하는 순간
						==> Object obj = new Object();
						이때 obj에는 Object의 객체의 주소가 기억이 될 것이고
						System.out.println(obj);
						라는 명령으로 출력을 하게되면..
						이때 toString()가 자동 호출이 되게 된다.
						
				결론 ]
					toString()는 주소를 출력할 때 자동 호출되어서
					출력할 내용을 만들어주는 함수이다.
					
					따라서
					우리는 만든 클래스를 출력할 때
					우리가 원하는 내용으로 고쳐써서(오버라이드해서) 사용하면 된다.
					
					참고 ]
						
						public void toString(String str){	// 이함수는 오버로딩을 해 놓은 경우다.
							System.out.println(str);
						}
		3. clone()
			==> 자기 자신을 깊은 복사해주는 함수
				
				주의 ]
					
					이 함수는 접근 지정자가 protected 이므로
					상속받은 클래스나 같은 패키지의 클래스에서만 사용할 수 있다.
					
		4. hashCode()
			==> 자바는 주소를 노출하지 않기 위해서
				해쉬테이블을 이용해서 주소를 관리한다.
				그 해쉬테이블에 주소를 관리하는 코드값을 알려주는 함수.
				
-----------------------------------------------------------------------------------------------

String 클래스와 StringBuffer 클래스의 차이점
	
	String 클래스는 문자열을 변경하게 되면
	매번 Heap 영역에 객체를 생성하게 되므로
	메모리 낭비가 극심해진다.
	따라서 이렇게 문자열의 수정이 빈번한 경우에는
	StringBuffer나 StringBuilder 를 사용해서 처리해주는 것이 좋다.
	단, StringBuffer나 StringBuilder를 사용해서 문자열 수정을 마치게 되면
	반드시 String 타입으로 변경시켜 주는 것이 좋다.
	<== 자바에서 사용하는 거의 대부분의 함수들의 매개변수가
		String 타입의 데이터를 입력해 달라고 원하기 때문에...
	이때 String 타입의 데이터로 변경시켜주는 함수가
		toString()
	함수이고 역시 Object 클래스에 toString() 함수를 오버라이딩 해놓은 함수이다.

------------------------------------------------------------------------------------
숙제 ]
	
	String, StringBuffer, StringBuilder 소속의 함수를 각각 10개 이상 조상하고 예제를 만들어 보세요.

------------------------------------------------------------------------------------

Math

==> 주로 수학적인 기능을 처리하는 함수로 구성 되어 있는 클래스
	모든 함수가 static 이므로
	굳이 new 시키지 않아도 사용할 수 있는 함수들이고
	아예 new 시키지 못하도록 해놓은 클래스이다.

-------------------------------------------------------------------------------------

래퍼 클래스 (Wrapper Class)

==> 주소를 사용(래퍼런스변수를 사용)하는 곳에 기본데이터타입을 사용할 수 없는 문제가 생긴다.
	이런 문제를 해결하기 위해서 만든 클래스를 래퍼 클래스(Wrapper Class)라고 한다.
	
	예를 들어
		int를 주소(인스턴스)로 사용할 수 있도록 하기위해 만든 클래스
		
	참고 ]
		
		자바는 Object를 중심으로 계층 구조화 해서
		클래스를 이용하도록 만드는 객체지향 언어이다.
		
		그러나 유일하게 기본데이터타입(Value Type) 만큼은 객체지향 원리를 사용하지 않는다.
		따라서 다형성 구현에 문제가 발생한다.
		
		예]
			void abc(Object o) {
			}
			
			==> 이 함수는 모든 내용을 처리하도록 만든 함수
				그런데 유일하게 기본데이터타입은 사용할 수 없다.
				
			그래서 이런 문제를 해결하기 위해서 만들어진 클래스가 Wrapper Class 이다.
			종류 ]
				Boolean, Character, Byte, Short, Integer, Long, Float, Double
				
				
		참고 ]
			
			Boxing 과 Unboxing
				
				Boxing	: 기본데이터타입을 객체 타입으로 변환 하는 것.
				Unboxing: 객체타입을 기본데이터타입으로 변환 하는 것
				
				따라서
				래퍼클래스란 Boxing과 Unboxing 을 해주기 위한 클래스
				
		참고 ]
			그런데 이제는 Boxing과 Unboxing을 몰라도 상관없다.
			<== 자바 버젼 1.4 이후 부터는 Boxing과 Unboxing이 자동으로 처리된다.
			
	결론 ]
		자바는 내부적으로 모든 정보를 주소로(래퍼런스로) 통일해서 사용할 수 있다.

-----------------------------------------------------------------------------

java.util 패키지 소속의 유용한 클래스
	
	1. Objects
	
		==> 이 클래스는 100% static 함수로만 구성되어있는 클래스
			클래스를 다룰 때 유용한 몇가지 유틸리티적인 함수로 구성된 클래스
			
			예 ]
				
				isNull(Object o)
				==> 객체에 내용이 있는지를 확인하는 함수
					다시 말해서 new 시킨 결과가 있는지를 확인하는 함수
					
					Object obj;
					
					try{
						xxxx
						obj = new Object();
						xxxx
					} catch(Exception e){}
					
		*****
		참고 ]
			null
				: 주소 변수에 주소가 없는 상태
					이것은 찾아갈 대상이 없다는 말이고
					이 말은 이것을 아직 사용할 준비가 되어 있지 않다.
					
------------------------------------------------------------------------------------

Random Class
	
	==> 난수를 발생하는 클래스
		우리가 사용해오던 Math.random() 보다는 좀더 다양한 형태의 난수를 발생할 수 있는 장점이 있다.
		
		참고 ]
			
			seed 란??
				
				컴퓨터에서 난수를 발생하는 것은
				그 순간 실제로 난수가 발생되는 것은 아니다.
				이미 컴퓨터 내부에는 난수 테이블이 존재하고
				컴퓨터는 그 테이블에서 순서대로 데이터를 꺼내서 주는 역할을 한다.
				
				seed란 난수 테이블에서 난수를 꺼내는 위치를 말하는 용어다.
				
				
				
----------------------------------------------------------------------------------

Arrays 클래스
	
	==> 역시 100% static 함수로만 구성된 클래스
		배열을 처리할 때 필요한 유틸리티적인 함수들로 구성된 클래스
		
		예 ]
			
			sort()
				==> 배열에 있는 데이터를 정렬하는 기능을 가진 함수
			
-------------------------------------------------------------------------------------

정규식 검사
	
	==> 주어진 문자열이 특정한 규칙에 맞도록 만들어져 있는지를 확인하는 기능
		
		예 ]
			
			주민등록번호는 6자리-7자리의 숫자로만 구성되어 있는가???
			아이디가 순수하게 숫자와 문자열로만 구성되어 있는가???
			아이디가 최소 몇글자 이상으로 만들어져 있는가???
			
	사용하는 클래스
		
		java.util.regex.Pattern
			==> 정규식 검사에 사용할 정규식 문법(패턴을)을 지정할 클래스
			
		java.util.regex.Matcher
			==> 정규식 검사를 실제로 실행할 클래스		
					
	참고 ]
		
		정규식 문법 ]
			
			1. c[a-z]*
				==> 글자를 특정위치에 기술하면 반드시 그 위치에 해당 글자가 와야 한다.
					[] 안에 기록하면 그 중 하나가 와야 한다.
					* 바로앞의 지정한 글자가 0개이상 올 수 있다.
					
				==> c로 시작하는 소문자 문자열
			
			2. c[a-z]
				==> c로 시작하고 다음 글자는 반드시 알파벳 소문자여야 한다.
				
			3. c[a-zA-Z]
				==> c로 시작하고 알파벳이 다음에 와야 한다.
				
			4. c[a-zA-Z0-9]
				==> 3번 + 숫자
					이 경우는 줄여서 c\w 로 사용할 수도 있다.
					
			5. .*
				==> .은 모든 문자(알파벳과 한글까지 포함)를 의미
				
				==> 무슨글자가 와도 상관없다.
			
			6. c.
				==> 첫글자로 c가 와야하고 다음은 아무문자 한개가 오면 된다.
				
			7. c.*
				==> c로 시작하고 다음은 아무문자가 0개이상 오면 된다.
				
			8. c\.
				==> \. 은 반드시 . 문자만 와야한다.
			
			9. c\d
				==> \d 는 숫자 문자를 의미
				==> 첫글자는 c로 시작하고 그다음은 숫자중 하나..
				==> c[0-9]
			
참고 ]
	자바에서 문자열 데이터에 큰따옴표를 포함하고 싶을 경우
	==> "가나다"라마"바사" ==> "가나다\"라마\"바사" 
	==> 이런경우 사용하는 문자를 이스케이프 문자라 칭한다.
		표현하고 싶은 기호에 역슬래시(\)를 붙여서 문자열에 포함시키는 방법이다.
		
			10. c.*t	==> "abcdc$tabc" 	 ^c.*t$	==> "agsade23e23^&t"
				==> 첫글자는 c가 와야하고
					그 다음은 아무문자나 몇자가 되던 상관없고
					그리고 마지막은 t로 끝나야 한다.
					
			11. [b|c].*
				==> b나 c로 시작하고
					그 이후는 아무문자나 몇개 이상 와도 상관없다.
			
			12. [^b|c]
				==> ^ 는 NOT의 의미
					b또는 c가 아닌 문자
			
			13. .*a.*
				==> a라는 문자가 포함된 문자열
			
			14. .*a.+
				==> * : 0개 이상
					+ : 1개 이상
					
			15. [b|c].{2}
				==> {} 안의 숫자의 의미는 글자의 갯수를 의미
				==> b또는 c로시작하는 3자리 문자열
			
			16. .{2, 3}
				==> {2,3}은 글자수를 의미
					, 는 OR 를 의미
					
			17. ^c
				==> 문자열의 첫글자는 반드시 c로 시작해야 한다.
				
			18. c$
				==> 문자열의 마지막 글자는 반드시 c로 끝나야 한다.  
	
		
				
		
		
		
		
		
		
		
				
				
	 	
		
	
	
	
	
	