# day15
	
	Object 클래스
		
		2. toString()
			==> 자바는 주소를 내부적으로 사용하고 있다.
				하지만 주소를 사용자(개발자)에게 노출하지는 않는다.
				
				대신 주소를 출력하면
					"클래스이름@해쉬코드값"
				의 형태로 출력을 한다.
				
				참고 ]
					해쉬코드
					==> 자바는 주소를 내부적으로 해쉬테이블을 이용해서 관리한다.
						해쉬코드값은 그 주소를 관리하는 해쉬테이블의 코드값이 된다.
						
				문제 ]
					주소를 출력하려고 하는 순간
						==> Object obj = new Object();
						이때 obj에는 Object의 객체의 주소가 기억이 될 것이고
						System.out.println(obj);
						라는 명령으로 출력을 하게되면..
						이때 toString()가 자동 호출이 되게 된다.
						
				결론 ]
					toString()는 주소를 출력할 때 자동 호출되어서
					출력할 내용을 만들어주는 함수이다.
					
					따라서
					우리는 만든 클래스를 출력할 때
					우리가 원하는 내용으로 고쳐써서(오버라이드해서) 사용하면 된다.
					
					참고 ]
						
						public void toString(String str){	// 이함수는 오버로딩을 해 놓은 경우다.
							System.out.println(str);
						}
		3. clone()
			==> 자기 자신을 깊은 복사해주는 함수
				
				주의 ]
					
					이 함수는 접근 지정자가 protected 이므로
					상속받은 클래스나 같은 패키지의 클래스에서만 사용할 수 있다.
					
		4. hashCode()
			==> 자바는 주소를 노출하지 않기 위해서
				해쉬테이블을 이용해서 주소를 관리한다.
				그 해쉬테이블에 주소를 관리하는 코드값을 알려주는 함수.
				
-----------------------------------------------------------------------------------------------

String 클래스와 StringBuffer 클래스의 차이점
	
	String 클래스는 문자열을 변경하게 되면
	매번 Heap 영역에 객체를 생성하게 되므로
	메모리 낭비가 극심해진다.
	따라서 이렇게 문자열의 수정이 빈번한 경우에는
	StringBuffer나 StringBuilder 를 사용해서 처리해주는 것이 좋다.
	단, StringBuffer나 StringBuilder를 사용해서 문자열 수정을 마치게 되면
	반드시 String 타입으로 변경시켜 주는 것이 좋다.
	<== 자바에서 사용하는 거의 대부분의 함수들의 매개변수가
		String 타입의 데이터를 입력해 달라고 원하기 때문에...
	이때 String 타입의 데이터로 변경시켜주는 함수가
		toString()
	함수이고 역시 Object 클래스에 toString() 함수를 오버라이딩 해놓은 함수이다.

------------------------------------------------------------------------------------
숙제 ]
	
	String, StringBuffer, StringBuilder 소속의 함수를 각각 10개 이상 조상하고 예제를 만들어 보세요.

------------------------------------------------------------------------------------

Math

==> 주로 수학적인 기능을 처리하는 함수로 구성 되어 있는 클래스
	모든 함수가 static 이므로
	굳이 new 시키지 않아도 사용할 수 있는 함수들이고
	아예 new 시키지 못하도록 해놓은 클래스이다.

-------------------------------------------------------------------------------------

래퍼 클래스 (Wrapper Class)

==> 주소를 사용(래퍼런스변수를 사용)하는 곳에 기본데이터타입을 사용할 수 없는 문제가 생긴다.
	이런 문제를 해결하기 위해서 만든 클래스를 래퍼 클래스(Wrapper Class)라고 한다.
	
	예를 들어
		int를 주소(인스턴스)로 사용할 수 있도록 하기위해 만든 클래스
		
	참고 ]
		
		자바는 Object를 중심으로 계층 구조화 해서
		클래스를 이용하도록 만드는 객체지향 언어이다.
		
		그러나 유일하게 기본데이터타입(Value Type) 만큼은 객체지향 원리를 사용하지 않는다.
		따라서 다형성 구현에 문제가 발생한다.
		
		예]
			void abc(Object o) {
			}
			
			==> 이 함수는 모든 내용을 처리하도록 만든 함수
				그런데 유일하게 기본데이터타입은 사용할 수 없다.
				
			그래서 이런 문제를 해결하기 위해서 만들어진 클래스가 Wrapper Class 이다.
			종류 ]
				Boolean, Character, Byte, Short, Integer, Long, Float, Double
				
				
		참고 ]
			
			Boxing 과 Unboxing
				
				Boxing	: 기본데이터타입을 객체 타입으로 변환 하는 것.
				Unboxing: 객체타입을 기본데이터타입으로 변환 하는 것
				
				따라서
				래퍼클래스란 Boxing과 Unboxing 을 해주기 위한 클래스
				
		참고 ]
			그런데 이제는 Boxing과 Unboxing을 몰라도 상관없다.
			<== 자바 버젼 1.4 이후 부터는 Boxing과 Unboxing이 자동으로 처리된다.
			
	결론 ]
		자바는 내부적으로 모든 정보를 주소로(래퍼런스로) 통일해서 사용할 수 있다.

-----------------------------------------------------------------------------

java.util 패키지 소속의 유용한 클래스
	
	1. Objects
	
		==> 이 클래스는 100% static 함수로만 구성되어있는 클래스
			클래스를 다룰 때 유용한 몇가지 유틸리티적인 함수로 구성된 클래스
			
			예 ]
				
				isNull(Object o)
				==> 객체에 내용이 있는지를 확인하는 함수
					다시 말해서 new 시킨 결과가 있는지를 확인하는 함수
					
					Object obj;
					
					try{
						xxxx
						obj = new Object();
						xxxx
					} catch(Exception e){}
					
		*****
		참고 ]
			null
				: 주소 변수에 주소가 없는 상태
					이것은 찾아갈 대상이 없다는 말이고
					이 말은 이것을 아직 사용할 준비가 되어 있지 않다.
					
------------------------------------------------------------------------------------

Random Class
	
	==> 난수를 발생하는 클래스
		우리가 사용해오던 Math.random() 보다는 좀더 다양한 형태의 난수를 발생할 수 있는 장점이 있다.
		
		참고 ]
			
			seed 란??
				
				컴퓨터에서 난수를 발생하는 것은
				그 순간 실제로 난수가 발생되는 것은 아니다.
				이미 컴퓨터 내부에는 난수 테이블이 존재하고
				컴퓨터는 그 테이블에서 순서대로 데이터를 꺼내서 주는 역할을 한다.
				
				seed란 난수 테이블에서 난수를 꺼내는 위치를 말하는 용어다.
				
				
				
----------------------------------------------------------------------------------

Arrays 클래스
	
	==> 역시 100% static 함수로만 구성된 클래스
		배열을 처리할 때 필요한 유틸리티적인 함수들로 구성된 클래스
		
		예 ]
			
			sort()
				==> 배열에 있는 데이터를 정렬하는 기능을 가진 함수
			
-------------------------------------------------------------------------------------

정규식 검사
	
	==> 주어진 문자열이 특정한 규칙에 맞도록 만들어져 있는지를 확인하는 기능
		
		예 ]
			
			주민등록번호는 6자리-7자리의 숫자로만 구성되어 있는가???
			아이디가 순수하게 숫자와 문자열로만 구성되어 있는가???
			아이디가 최소 몇글자 이상으로 만들어져 있는가???
			
	사용하는 클래스
		
		java.util.regex.Pattern
			==> 정규식 검사에 사용할 정규식 문법(패턴을)을 지정할 클래스
			
		java.util.regex.Matcher
			==> 정규식 검사를 실제로 실행할 클래스		
					
	참고 ]
		
		정규식 문법 ]
			
			1. c[a-z]*
				==> 글자를 특정위치에 기술하면 반드시 그 위치에 해당 글자가 와야 한다.
					[] 안에 기록하면 그 중 하나가 와야 한다.
					* 바로앞의 지정한 글자가 0개이상 올 수 있다.
					
				==> c로 시작하는 소문자 문자열
			
			2. c[a-z]
				==> c로 시작하고 다음 글자는 반드시 알파벳 소문자여야 한다.
				
			3. c[a-zA-Z]
				==> c로 시작하고 알파벳이 다음에 와야 한다.
				
			4. c[a-zA-Z0-9]
				==> 3번 + 숫자
					이 경우는 줄여서 c\w 로 사용할 수도 있다.
					
			5. .*
				==> .은 모든 문자(알파벳과 한글까지 포함)를 의미
				
				==> 무슨글자가 와도 상관없다.
			
			6. c.
				==> 첫글자로 c가 와야하고 다음은 아무문자 한개가 오면 된다.
				
			7. c.*
				==> c로 시작하고 다음은 아무문자가 0개이상 오면 된다.
				
			8. c\.
				==> \. 은 반드시 . 문자만 와야한다.
			
			9. c\d
				==> \d 는 숫자 문자를 의미
				==> 첫글자는 c로 시작하고 그다음은 숫자중 하나..
				==> c[0-9]
			
참고 ]
	자바에서 문자열 데이터에 큰따옴표를 포함하고 싶을 경우
	==> "가나다"라마"바사" ==> "가나다\"라마\"바사" 
	==> 이런경우 사용하는 문자를 이스케이프 문자라 칭한다.
		표현하고 싶은 기호에 역슬래시(\)를 붙여서 문자열에 포함시키는 방법이다.
		
			10. c.*t	==> "abcdc$tabc" 	 ^c.*t$	==> "agsade23e23^&t"
				==> 첫글자는 c가 와야하고
					그 다음은 아무문자나 몇자가 되던 상관없고
					그리고 마지막은 t로 끝나야 한다.
					
			11. [b|c].*
				==> b나 c로 시작하고
					그 이후는 아무문자나 몇개 이상 와도 상관없다.
			
			12. [^b|c]
				==> ^ 는 NOT의 의미
					b또는 c가 아닌 문자
			
			13. .*a.*
				==> a라는 문자가 포함된 문자열
			
			14. .*a.+
				==> * : 0개 이상
					+ : 1개 이상
					
			15. [b|c].{2}
				==> {} 안의 숫자의 의미는 글자의 갯수를 의미
				==> b또는 c로시작하는 3자리 문자열
			
			16. .{2, 3}
				==> {2,3}은 글자수를 의미
					, 는 OR 를 의미

// 이 부분은 자바스크립트 문법입니다.					
			17. ^c
				==> 문자열의 첫글자는 반드시 c로 시작해야 한다.
				
			18. c$
				==> 문자열의 마지막 글자는 반드시 c로 끝나야 한다.  
	
--------------------------------------------------------------------------------

Scanner Class
	==> 외부장치를 이용해서 데이터를 받아들이기 위한 클래스
		
		참고 ]
			원래 자바는 IO라는 개념을 이용해서 외부장치와 연결한다.
			그러다보니 간단한 테스트를 위해서도 IO 처리를 해야하므로
			개발자가 매우 불편했었다.
			
			자바버젼 1.5 부터 만들어진 기능이다.
			
		생성자 함수
			==> 외부장치인 File이나 IO인 Stream을 넣어달라고 하고 있다.
			
		참고 ]
			System.in
				==> 내부적으로 키보드와 연결한 스트림으로 만들어 놓은 것
				
					우리가
					Scanner sc = new Scanner(System.in);
					==> 키보드를 통해서 입력받는 Scanner가 된 것이다.
					
-----------------------------------------------------------------------------------

StringTokenizer
	
	==> 하나의 문자열을 원하는 문자를 기준으로 나누는 기능을 가진 클래스
		
		사용이유 ]
			네트워크등을 이용하면
			여러개의 데이터가 한번에 들어올 수 있다.
			
		예 ]
			카톡을 하면
			카톡을 보낸사람, 보낸시간, 내용, ...등이
			하나의 문자열로 구성되어서 한번에 들어온다.
			==> 이런 경우 각각의 데이터를 분리해서 처리해야 할 것이다.
				보낸사람@보낸시간@내용
				
		생성방법 ]
			
			1. StringTokenizer(String str)
				==> 문자열을 공백을 기준으로 나누는 기능
				
			2. StringTokenizer(String str, String delim)
				==> 문자열을 지정한 문자(String delim)를 기준으로 나누는 기능
				
			3. StringTokenizer(String str, String delim, boolean returnDelims)
				==> 2 + 구분문자도 하나의 문자로 처리한다.
				
		참고 ]
			분리된 결과는 임시 버퍼에 기억이 되어있다.
			***
			따라서 이것은 특징이 한번 사용하면 버퍼에서 그순간 지워버린다.
			따라서 한번 사용하면 더이상 사용할 수 없게 되고
			***
			반드시 순서대로만 꺼내야 한다.
			
		주요함수 ]
			
			countTokens()
				==> 문자열을 나눈 결과 수를 반환해주는 함수
				
			hasMoreElements() / hasMoreTokens()
				==> 임시버퍼에 내용이 남아있는지 여부를 묻는 함수
				
			nextElement() / nextToken()
				==> 데이터를 꺼내는 함수
				
------------------------------------------------------------------------------

BigDecimal
	==> 정수로 표현할 수 없는 숫자를 사용하기 위한 클래스
		
		주로 데이터베이스와 연동할 때
		오라클의 데이터는 number(숫자)
			이 숫자는 38자리까지 사용할 수 있다.
		이런 데이터는 자바에서는 처리할 수 없으므로
		이런 유형의 데이터를 처리하기 위해서 만들어진 클래스이다.
		
		예 ]
			
			BigDecimal big = new BigDecimal("12345678901234568901234567890");
			
----------------------------------------------------------------------------------

Date 클래스
	
	==> 날짜와 시간을 관리하는 클래스
		
		생성자 함수 ]
			
			Date()
				==> 현재 시스템의 날짜와 시간을 이용해서 관리
				
			나머지 생성자
				==> 지정한 날짜와 시간을 이용해서 관리
				
		참고 ]
			이 클래스는 Calendar 클래스가 버젼업 버젼이므로
			자바는 Calendar 클래스 사용을 권장하고 있다.
			하지만 아직도 Date 클래스를 사용해야 하는 함수가 존재한다.
			따라서 알고는 있어야 한다.
			
--------------------------------------------------------------------------------

Calendar Class
	==> Date 클래스를 버젼업 시켜놓은 클래스
		
		생성방법 ]
			
			**
			이 클래스는 생성자 함수를 감춰놓은 경우에 해당하므로
			스스로 new 시켜서 객체를 만들수는 없고
			함수중 속성이 static 이면서 반환값이 Calendar 인 함수를 찾아서 객체를 사용해야 한다.
			
			Calendar car = new Calendar() ==> X
			
			Calendar car = Calendar.getInstance(); ==> O
		
		주요함수 ]
			
			get(int field)
				==> 필요한 정보를 알려주는 함수
					이 함수는 int field에 알고자하는 내용을 알려주면
					그 값에 대해서 알려주는 함수이다.
					
					중요 ]
						
						Calendar 클래스는
						각각의 변수가 무엇을 알기 위한 변수인지를 공부해 놓는 것이 좋다.
						Field Summery를 보세요..
			
			
			getTime()
				==> Calendar 클래스를 Date 클래스로 변환하는 함수
					
					실무에서는 Calendar 클래스를 이용해서 작업을 하다가
					필요하면 Date클래스로 변환해서 사용할 필요가 있다.
					
					예 ]
						
						Calendar car = Calendar.getInstance();
						....
						Date d = car.getTime();
						
				참고 ]
					자바의 API의 함수 이용 방법
						
						자바의 함수를 보면 문자열로 의미하는 내용을
						int로 입력해 달라는 함수가 많이 존재한다.
						이런 경우는 99% 가 자기자신이 가진 그 문자열을 의미하는 숫자를
						담아 놓은 변수를 가지고 있다.
						그 변수를 이용해서 처리하면 된다.
						
						예 ]
							JOptionPane.showConfirmDialog(Component parentComponet, 
											Object message, String title, int optionType);
											
							==> int optionType은 이미 JOptionPane에서 정의 해놓은 상수가 존재하고
								그 상수를 입력해주면 된다.
						
						
									
				
		
		
		
		
		
		
		
				
				
	 	
		
	
	
	
	
	